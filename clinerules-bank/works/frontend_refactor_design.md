# Frontend リファクタリング設計案

## 現状の課題と要件

- **マルチチャネル対応**: Web、Line、電話等の複数フロントエンドを追加予定
- **責務の明確化**: 複雑なロジックはバックエンドに集約、フロントエンドはUIに特化
- **拡張性**: ユーザーとクライアントのマッチング機能の追加

## リファクタリング案

### 案1: ドメイン駆動設計（DDD）ベース

```
frontend/src/
├── app/                        # Next.js App Router
├── domains/                    # ビジネスドメイン
│   ├── auth/                   # 認証関連
│   │   ├── components/
│   │   ├── hooks/
│   │   └── types/
│   ├── reception/              # 受付機能
│   │   ├── components/
│   │   ├── hooks/
│   │   └── types/
│   ├── matching/               # マッチング機能
│   │   ├── components/
│   │   ├── hooks/
│   │   └── types/
│   └── summary/                # 要約機能
│       ├── components/
│       ├── hooks/
│       └── types/
├── shared/                     # 共通機能
│   ├── components/             # 共通コンポーネント
│   ├── contexts/               # グローバルコンテキスト
│   ├── hooks/                  # 共通フック
│   ├── types/                  # 共通型定義
│   └── utils/                  # ユーティリティ
├── channels/                   # チャネル別実装
│   ├── web/                    # Webインターフェース
│   ├── voice/                  # 音声専用インターフェース
│   └── line/                   # LINE連携
└── config/                     # 設定ファイル

#### メリット
- **高い凝集性**: ドメインごとに関連するコードが集約され、機能単位での理解が容易
- **並行開発**: チーム間での作業分担が明確で、コンフリクトが少ない
- **ドメイン知識の反映**: ビジネスロジックの構造がコード構造に直接反映される
- **テスタビリティ**: ドメイン単位でのテストが書きやすい

#### デメリット
- **初期学習コスト**: DDDの概念理解が必要
- **オーバーエンジニアリング**: 小規模プロジェクトでは過剰な構造
- **横断的機能の実装**: 複数ドメインにまたがる機能の実装が複雑になりがち
- **コード重複の可能性**: ドメイン間で似たようなコードが発生しやすい

#### 特徴
- ビジネスドメインを中心とした設計
- 各ドメインが独立して進化可能
- マイクロフロントエンド化への移行が容易

#### 拡張性
- **強い部分**: 新規ドメインの追加、既存ドメインの独立した拡張
- **弱い部分**: ドメイン間の連携機能、共通機能の大規模な変更

---

### 案2: 機能別（Feature-based）構成

```

frontend/src/
├── app/                        # Next.js App Router
├── features/                   # 機能別モジュール
│   ├── authentication/         # 認証機能
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── services/
│   │   ├── stores/
│   │   └── types/
│   ├── voice-chat/            # 音声チャット機能
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── services/
│   │   ├── stores/
│   │   └── types/
│   ├── client-matching/       # クライアントマッチング
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── services/
│   │   ├── stores/
│   │   └── types/
│   └── conversation-summary/   # 会話要約
│       ├── components/
│       ├── hooks/
│       ├── services/
│       ├── stores/
│       └── types/
├── core/                       # コア機能
│   ├── api/                    # API通信層
│   ├── config/                 # 設定
│   ├── constants/              # 定数
│   └── providers/              # プロバイダー
├── ui/                         # UI層
│   ├── components/             # 基本UIコンポーネント
│   ├── layouts/                # レイアウト
│   ├── styles/                 # スタイル
│   └── themes/                 # テーマ
└── lib/                        # ライブラリ層
    ├── utils/                  # ユーティリティ
    └── validators/             # バリデーション

#### メリット

- **機能の独立性**: 各機能が完全に独立したモジュールとして管理される
- **スケーラビリティ**: 新機能の追加が既存コードに影響を与えにくい
- **明確な責任範囲**: 各featureが自己完結的で責任範囲が明確
- **リファクタリング容易**: 機能単位での置き換えや削除が簡単

#### デメリット

- **初期構築の複雑さ**: 各機能モジュールの境界定義が難しい
- **共通コンポーネントの管理**: どこまでを共通化するかの判断が必要
- **ディレクトリの深さ**: ネストが深くなりナビゲーションが面倒
- **機能間の依存**: 機能間の連携が複雑になる可能性

#### 特徴

- 各機能が完全に独立したモジュール
- 機能の追加・削除が容易
- マイクロサービス的なアプローチ

#### 拡張性

- **強い部分**: 新機能追加、既存機能の独立した改修、機能の削除
- **弱い部分**: 機能横断的な変更、UIの統一的な変更

---

### 案3: レイヤードアーキテクチャ

```
frontend/src/
├── app/                        # Next.js App Router
├── presentation/               # プレゼンテーション層
│   ├── components/             # UIコンポーネント
│   │   ├── common/            # 共通コンポーネント
│   │   ├── forms/             # フォーム関連
│   │   ├── modals/            # モーダル
│   │   └── pages/             # ページコンポーネント
│   ├── layouts/                # レイアウト
│   └── styles/                 # スタイル定義
├── application/                # アプリケーション層
│   ├── hooks/                  # カスタムフック
│   ├── contexts/               # コンテキスト
│   └── services/               # サービスレイヤー
├── domain/                     # ドメイン層
│   ├── models/                 # ドメインモデル
│   ├── types/                  # 型定義
│   └── validators/             # バリデーション
├── infrastructure/             # インフラ層
│   ├── api/                    # API通信
│   ├── websocket/              # WebSocket通信
│   ├── storage/                # ローカルストレージ
│   └── external/               # 外部サービス連携
├── interfaces/                 # インターフェース定義
│   ├── web/                    # Web UI
│   ├── voice/                  # 音声UI
│   └── mobile/                 # モバイルUI
└── config/                     # 設定

#### メリット
- **明確な責任分離**: 各層の責任が明確で、変更の影響範囲を限定できる
- **テスタビリティ**: 層ごとにモックを作成しやすくテストが書きやすい
- **保守性**: アーキテクチャパターンが確立されており、理解しやすい
- **再利用性**: 下位層のコードは上位層から再利用可能

#### デメリット
- **抽象化の過剰**: 小規模アプリには過度な抽象化
- **開発速度**: 層を跨ぐ変更が必要な場合、複数ファイルの修正が必要
- **学習曲線**: 新規メンバーが全体像を理解するのに時間がかかる
- **ボイラープレート**: 各層でのインターフェース定義等が冗長

#### 特徴
- クリーンアーキテクチャの原則に従った設計
- 依存関係が一方向（外側から内側）
- ビジネスロジックとUIの完全な分離

#### 拡張性
- **強い部分**: UI層の変更、外部API連携の追加、テスト追加
- **弱い部分**: アーキテクチャ全体の変更、層を跨ぐ機能追加

---

## 推奨案

### 短期的推奨: 案2（機能別構成）
- **理由**: 
  - 現在の規模と要件に最適
  - マルチチャネル対応が容易
  - チーム開発での並行作業がしやすい
  - 段階的な機能追加が可能

### 長期的推奨: 案1（DDDベース）への移行
- **理由**:
  - ビジネスドメインが明確になってきた段階で移行
  - マイクロフロントエンド化を視野に入れた場合に有効
  - ドメイン知識をコードに反映しやすい

## 移行戦略

1. **Phase 1**: 現状から案2への移行（1-2週間）
   - 既存コードを機能別に整理
   - 共通コンポーネントの抽出

2. **Phase 2**: マルチチャネル対応（2-3週間）
   - 音声専用インターフェースの追加
   - LINE連携機能の実装

3. **Phase 3**: ドメイン境界の明確化（継続的）
   - ビジネスロジックの整理
   - 将来的な案1への移行準備

## 技術的考慮事項

### 状態管理
- Zustand または Redux Toolkit を採用
- 各feature/domainで独立したストアを持つ

### API通信
- TanStack Query (React Query) の採用
- バックエンドとの型安全な通信（tRPC検討）

### コンポーネント設計
- Atomic Designの部分的採用
- Storybookによるコンポーネントカタログ

### テスト戦略
- 単体テスト: Vitest
- 統合テスト: Testing Library
- E2Eテスト: Playwright
